#!/usr/bin/env bash

# bi-keycloak: Utilities for managing Keycloak images and deployments
#
# This script helps manage Keycloak images, including building, pushing,
# and synchronizing with upstream versions.

# Strict mode settings
set -Eeuo pipefail
set -o nounset  # Error on unset variables
set -o errtrace # Make sure any error trap is inherited

# Get script location and root directory
SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
ROOT_DIR=$(cd "$SCRIPT_DIR/.." &>/dev/null && pwd -P)

# Load common functions
source "${ROOT_DIR}/bin/lib/common-functions.sh"

# Parse the registry YAML file to get tag information
parse_registry_yaml() {
    local registry_file="${ROOT_DIR}/image_registry.yaml"

    if [[ ! -f "${registry_file}" ]]; then
        die "Registry file not found at ${registry_file}"
    fi

    log_info "Reading registry data from ${CYAN}${registry_file}${NOFORMAT}"
    UPSTREAM_TAGS=$(yq '.keycloak_upstream.tags[]' "${registry_file}")
    KEYCLOAK_TAGS=$(yq '.keycloak.tags[]' "${registry_file}")

    if [[ -z "${UPSTREAM_TAGS}" ]]; then
        log_warn "No upstream tags found in registry file"
    fi

    if [[ -z "${KEYCLOAK_TAGS}" ]]; then
        log_warn "No keycloak tags found in registry file"
    fi
}

# Strip version hash from tags (e.g., 26.3.0-16b3adf7c -> 26.3.0)
strip_version_hash() {
    local tags="$1"
    echo "${tags}" | sed -E 's/(-\w+)$//' | sort -u
}

# Find tags that are in upstream but not in our keycloak images
find_missing_tags() {
    local upstream="$1"
    local keycloak="$2"

    echo "${upstream} ${keycloak}" | tr ' ' '\n' | sort | uniq -u
}

# Trigger GitHub workflow for missing upstream tags
do_trigger_missing_upstream() {
    log_info "Checking for missing upstream tags in Keycloak"

    parse_registry_yaml

    # Strip version hashes from keycloak tags to get base versions
    local clean_keycloak_tags
    clean_keycloak_tags=$(strip_version_hash "${KEYCLOAK_TAGS}")

    log_debug "Upstream tags: ${UPSTREAM_TAGS}"
    log_debug "Keycloak tags (clean): ${clean_keycloak_tags}"

    # Find missing tags (in either direction)
    local missing_tags
    missing_tags=$(find_missing_tags "${UPSTREAM_TAGS}" "${clean_keycloak_tags}")

    if [[ -z "${missing_tags}" ]]; then
        log_success "No missing tags found - all upstream tags are covered"
        return 0
    fi

    log_info "Found ${YELLOW}$(echo "${missing_tags}" | wc -w)${NOFORMAT} missing tags"

    local trigger_count=0
    for tag in ${missing_tags}; do
        log_action "Triggering workflow for version ${CYAN}${tag}${NOFORMAT}"
        echo gh workflow run "keycloak.yml" -f "version=${tag}"
        trigger_count=$((trigger_count + 1))
    done

    log_info "Triggered ${YELLOW}${trigger_count}${NOFORMAT} workflow runs"
}

# Get the full Keycloak image name with tag
get_keycloak_image_name() {
    local upstream_tag="$1"
    local version_tag="$2"
    local image_name="${REGISTRY}/keycloak"

    echo "${image_name}:${upstream_tag}-${version_tag}"
}

# Validate that an image exists before trying to push it
validate_image_exists() {
    local image_name="$1"

    log_debug "Checking if image exists: ${image_name}"

    if ! docker image inspect "${image_name}" &>/dev/null; then
        log_error "Image not found: ${image_name}"
        log_info "Try building the image first with: ${CYAN}bi-docker build-image keycloak ${upstream_tag}${NOFORMAT}"
        return 1
    fi

    log_debug "Image exists: ${image_name}"
    return 0
}

# Push a Keycloak image to the registry
do_push_keycloak_image() {
    if [[ $# -lt 1 ]]; then
        die "Missing upstream tag. Usage: ${BASH_SOURCE[0]} push-keycloak <upstream_tag>"
    fi

    local upstream_tag="$1"
    local version_tag
    version_tag=$(version_tag)
    local image_name
    image_name=$(get_keycloak_image_name "${upstream_tag}" "${version_tag}")

    log_info "Preparing to push Keycloak image: ${CYAN}${image_name}${NOFORMAT}"

    # Validate the image exists before pushing
    if ! validate_image_exists "${image_name}"; then
        return 1
    fi

    log_action "Pushing image ${CYAN}${image_name}${NOFORMAT} to registry"

    if ! docker push "${image_name}"; then
        log_error "Failed to push image: ${image_name}"
        return 1
    fi

    log_success "Successfully pushed image: ${CYAN}${image_name}${NOFORMAT}"
}

# Display help information and exit
usage() {
    cat <<EOF
${CYAN}Batteries Included - Keycloak Management Tool${NOFORMAT}

${GREEN}USAGE:${NOFORMAT}
    $(basename "${BASH_SOURCE[0]}") [OPTIONS] COMMAND [ARGS...]

${GREEN}OPTIONS:${NOFORMAT}
    -h, --help          Show this help message and exit
    -v, --verbose       Enable verbose output (debug logging)
    --no-color          Disable colored output

${GREEN}COMMANDS:${NOFORMAT}
    ${YELLOW}trigger-missing-upstream${NOFORMAT}
        Identify and trigger GitHub workflows for upstream Keycloak tags 
        that don't have corresponding Batteries Included images

    ${YELLOW}push-keycloak${NOFORMAT} <upstream_tag>
        Push a Keycloak image with the specified upstream tag to the registry
        Example: bi-keycloak push-keycloak 26.3.0

${GREEN}EXAMPLES:${NOFORMAT}
    # Check for missing upstream tags and trigger workflows
    bi-keycloak trigger-missing-upstream

    # Push a specific Keycloak image version
    bi-keycloak push-keycloak 26.3.0
EOF
    exit 1
}

# Parse command line parameters
parse_params() {
    # Set default values
    export TRACE=${TRACE:-0}
    export NO_COLOR=${NO_COLOR:-0}

    while :; do
        case "${1-}" in
        -h | --help)
            usage
            ;;
        -v | --verbose)
            export TRACE=1
            ;;
        --no-color)
            export NO_COLOR=1
            ;;
        -?*)
            log "Unknown option: $1"
            usage
            ;;
        *)
            break
            ;;
        esac
        shift
    done

    if [[ $# -lt 1 ]]; then
        log "Missing command argument"
        usage
    fi

    COMMAND="$1"
    shift
    ARGS=("$@")

    log "Command: ${COMMAND}"
    log "Arguments: ${ARGS[*]:-none}"

    return 0
}

# Initialize the script environment
initialize() {
    setup_colors
    setup_trace
    setup_root
    maybe_add_to_path "${ROOT_DIR}/bin"
    export PATH

    # Set up error trap
    trap 'log "Error occurred at line $LINENO. Command: $BASH_COMMAND"' ERR

}

# Main entry point
main() {
    parse_params "$@"
    initialize

    log_info "Running command: ${YELLOW}${COMMAND}${NOFORMAT}"

    case "$COMMAND" in
    trigger-missing-upstream)
        do_trigger_missing_upstream
        ;;
    push-keycloak)
        if [[ ${#ARGS[@]} -lt 1 ]]; then
            log "Missing upstream tag argument for push-keycloak"
            usage
        fi
        do_push_keycloak_image "${ARGS[0]}"
        ;;
    *)
        log "Unknown command: ${COMMAND}"
        usage
        ;;
    esac

    log "Command ${YELLOW}${COMMAND}${NOFORMAT} completed successfully"
}

# Run the main function with all arguments
main "$@"
