#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

# Get where the current script is located
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
# Get the root directory of the project
root_dir=$(cd "$script_dir/.." &>/dev/null && pwd -P)
tempdirs=()

TRACE=${TRACE-0}

usage() {
    cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v] [-f] command [arg1...]

Available options:

-h, --help      Print this help and exit
-v, --verbose   Print script debug info
EOF
    exit
}

run_bi() {
    pushd "${root_dir}/bi" >/dev/null
    # shellcheck disable=SC2068
    go run bi $@
}

run_mix() {
    pushd "${root_dir}/platform_umbrella" >/dev/null
    # shellcheck disable=SC2068
    mix $@
}

## From an install spec file get the slug
get_slug() {
    local input=${1:-"bootstrap/dev.spec.json"}
    if [[ -f ${input} ]]; then
        input=$(realpath "${input}")
        run_bi debug spec-slug "${input}"
    else
        echo "${input}"
    fi
}

get_summary_path() {
    local slug=${1}
    log "${GREEN}Getting summary path${NOFORMAT} for $slug"
    run_bi debug install-summary-path "$slug"
}

## Stop a running installation
# Will take in either a spec file or a slug
do_stop() {
    local input=${1:-"bootstrap/dev.spec.json"}
    local slug
    # If install path is a file then we need to get the slug
    # from the file
    if [[ -f ${input} ]]; then
        input=$(realpath "${input}")
        slug=$(get_slug "${input}")
    else
        # Otherwise we can just stop the install path assuming it's a slug already
        slug=${input}
    fi
    log "${CYAN}Stopping${NOFORMAT} $slug"
    run_bi stop "$slug"
}

## Start a new installation
do_start() {
    local spec_path=${1:-"bootstrap/dev.spec.json"}
    # If spec path isn't a file fail out
    if [[ ! -f ${spec_path} ]]; then
        die "Spec file not found: ${spec_path}"
    fi

    spec_path=$(realpath "${spec_path}")
    log "${GREEN}Starting${NOFORMAT} ${spec_path}"
    run_bi start "${spec_path}"
}

do_bootstrap() {
    local spec_path=${1:-"bootstrap/dev.spec.json"}
    spec_path=$(realpath "${spec_path}")

    do_start "${spec_path}"
}

cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    for tempdir in "${tempdirs[@]}"; do
        rm -rf "$tempdir" || true
    done

    for pid in $(pgrep -P $$); do
        # This is kind of a kludge to get around sending
        # a signal to the forked off bash, flock,
        # and bi which is portforwarding
        for child in $(pgrep -P "$pid"); do
            log "${ORANGE}Killing child${NOFORMAT} $child"
            pkill -P "$child" >/dev/null 2>&1 || true
            kill "$child" >/dev/null 2>&1 || true
        done

        pkill -P "$pid" >/dev/null 2>&1 || true
        kill "$pid" >/dev/null 2>&1 || true
    done

    local jobs
    jobs=$(jobs -pr)

    for job in $jobs; do
        log "${ORANGE}Killing job${NOFORMAT} $job"
        kill "$job" >/dev/null 2>&1 || true
    done

    pkill -P $$ || true
}

setup_colors() {
    if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
        NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
    else
        NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
    fi
}

setup_trace() {
    if [[ $TRACE -eq 1 ]]; then
        log "${GREEN}Tracing enabled${NOFORMAT}"
        set -x
    fi
}

setup_root() {
    log "${GREEN}Entering root directory: $root_dir${NOFORMAT}"
    pushd "$root_dir" >/dev/null
}

log() {
    echo >&2 -e "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*"
}

die() {
    local msg=$1
    local code=${2-1}
    log "$msg"
    exit "$code"
}

parse_params() {
    while :; do
        case "${1-}" in
        -h | --help) usage ;;
        -v | --verbose) TRACE=1 ;;
        --no-color) NO_COLOR=1 ;;
        -?*) die "Unknown option: $1" ;;
        *) break ;;
        esac
        shift
    done

    if [[ $# -lt 1 ]]; then
        die "Missing script arguments"
    fi

    command="$1"
    shift
    args=("$@")

    return 0
}

parse_params "$@"
setup_colors
setup_trace
setup_root

case "$command" in
start)
    do_start "${args[@]}"
    ;;
stop)
    do_stop "${args[@]}"
    ;;

*) ;;
esac
