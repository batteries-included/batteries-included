#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

# Get where the current script is located
script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)
# Get the root directory of the project
root_dir=$(cd "$script_dir/.." &>/dev/null && pwd -P)
tempdirs=()

TRACE=${TRACE-0}

usage() {
    cat <<EOF
Usage: $(basename "${BASH_SOURCE[0]}") [-h] [-v] [-f] command [arg1...]

Available options:

-h, --help      Print this help and exit
-v, --verbose   Print script debug info

Available commands:


## Install Related Commands
- start             Start a new installation
- stop              Stop a running installation

## Development Commands
- fmt               Format all code in the project
- check-fmt         Check if all code in the project is formatted
- gen-static-specs  Generate static installation specs

## Go Commands
- go-update-deps    Update go dependencies
- go-test           Run go tests
- go-test-int       Run go integration tests
EOF
    exit
}

run_bi() {
    pushd "${root_dir}/bi" >/dev/null
    # shellcheck disable=SC2068
    go run bi $@
}

run_mix() {
    pushd "${root_dir}/platform_umbrella" >/dev/null
    # shellcheck disable=SC2068
    mix $@
    popd >/dev/null
}

## From an install spec file get the slug
get_slug() {
    local input=${1:-"bootstrap/dev.spec.json"}
    if [[ -f ${input} ]]; then
        input=$(realpath "${input}")
        run_bi debug spec-slug "${input}"
    else
        echo "${input}"
    fi
}

update_go_deps() {
    local go_path=${1}
    pushd "${go_path}" >/dev/null
    log "${BLUE}Updating go dependencies${NOFORMAT} in ${go_path}"
    go get -u ./...
    go mod tidy
    gomod2nix
    popd
}

run_go_test() {
    local go_path=${1}
    pushd "${go_path}" >/dev/null
    log "${BLUE}Running go tests${NOFORMAT} in ${go_path}"
    gofmt -s -l -e .
    go vet -v ./...
    # If trace run tests with --race -v
    # Otherwise just run the tests
    if [[ -n ''${TRACE:-""} ]]; then
        go test --race -v ./...
    else
        go test ./...
    fi
    popd >/dev/null
}

get_summary_path() {
    local slug=${1}
    log "${GREEN}Getting summary path${NOFORMAT} for $slug"
    run_bi debug install-summary-path "$slug"
}

## Stop a running installation
# Will take in either a spec file or a slug
do_stop() {
    local input=${1:-"bootstrap/dev.spec.json"}
    local slug
    # If install path is a file then we need to get the slug
    # from the file
    if [[ -f ${input} ]]; then
        input=$(realpath "${input}")
        slug=$(get_slug "${input}")
    else
        # Otherwise we can just stop the install path assuming it's a slug already
        slug=${input}
    fi
    log "${CYAN}Stopping${NOFORMAT} $slug"
    run_bi stop "$slug"
}

## Start a new installation
do_start() {
    local spec_path=${1:-"bootstrap/dev.spec.json"}
    # If spec path isn't a file fail out
    if [[ ! -f ${spec_path} ]]; then
        die "Spec file not found: ${spec_path}"
    fi

    spec_path=$(realpath "${spec_path}")
    log "${GREEN}Starting${NOFORMAT} ${spec_path}"
    run_bi start "${spec_path}"
}

do_bootstrap() {
    local spec_path=${1:-"bootstrap/dev.spec.json"}
    spec_path=$(realpath "${spec_path}")

    do_start "${spec_path}"
}

format_mix_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Formatting elixir code in ${BLUE}${path}${NOFORMAT}"
    run_mix "do" deps.get, format >/dev/null
    popd >/dev/null

}

check_format_mix_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Checking elixir code in ${BLUE}${path}${NOFORMAT}"
    run_mix "do" deps.get, format --check-formatted >/dev/null
    popd >/dev/null

}

format_go_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Formatting golang code in ${BLUE}${path}${NOFORMAT}"
    gofmt -s -w . >/dev/null
    popd >/dev/null
}

check_format_go_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Checking golang code in ${BLUE}${path}${NOFORMAT}"
    test -z $(gofmt -l .)
    popd >/dev/null
}

format_npm_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Formatting npm code in ${BLUE}${path}${NOFORMAT}"
    npm ci >/dev/null
    npx prettier --write . >/dev/null
    popd >/dev/null
}

check_format_npm_code() {
    local path=${1}
    pushd "${path}" >/dev/null
    log "Checking npm code in ${BLUE}${path}${NOFORMAT}"
    npm ci >/dev/null
    npx prettier --check . >/dev/null
    popd >/dev/null
}

do_fmt() {
    format_mix_code "platform_umbrella"
    format_go_code "bi"
    format_go_code "pastebin-go"
    format_npm_code "static"
}

do_check_fmt() {
    check_format_mix_code "platform_umbrella"
    check_format_go_code "bi"
    check_format_go_code "pastebin-go"
    check_format_npm_code "static"
}

do_gen_static_specs() {
    rm -rf "${root_dir}/bootstrap"
    VERSION_OVERRIDE=''${VERSION_OVERRIDE:-"latest"} \
        run_mix "do" deps.get, compile, \
        gen.static.installations "${root_dir}/bootstrap"
}

do_go_update_deps() {
    update_go_deps "${root_dir}/bi"
    update_go_deps "${root_dir}/pastebin-go"
}

do_go_test() {
    run_go_test "${root_dir}/bi"
}

do_go_test_int() {
    export INTEGRATION=true
    run_go_test "${root_dir}/bi"
}

cleanup() {
    trap - SIGINT SIGTERM ERR EXIT
    for tempdir in "${tempdirs[@]}"; do
        rm -rf "$tempdir" || true
    done

    for pid in $(pgrep -P $$); do
        # This is kind of a kludge to get around sending
        # a signal to the forked off bash, flock,
        # and bi which is portforwarding
        for child in $(pgrep -P "$pid"); do
            log "${ORANGE}Killing child${NOFORMAT} $child"
            pkill -P "$child" >/dev/null 2>&1 || true
            kill "$child" >/dev/null 2>&1 || true
        done

        pkill -P "$pid" >/dev/null 2>&1 || true
        kill "$pid" >/dev/null 2>&1 || true
    done

    local jobs
    jobs=$(jobs -pr)

    for job in $jobs; do
        log "${ORANGE}Killing job${NOFORMAT} $job"
        kill "$job" >/dev/null 2>&1 || true
    done

    pkill -P $$ || true
}

setup_colors() {
    if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
        NOFORMAT='\033[0m' RED='\033[0;31m' GREEN='\033[0;32m' ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m' YELLOW='\033[1;33m'
    else
        NOFORMAT='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
    fi
}

setup_trace() {
    if [[ $TRACE -eq 1 ]]; then
        log "${GREEN}Tracing enabled${NOFORMAT}"
        set -x
    fi
}

setup_root() {
    log "${GREEN}Entering root directory: $root_dir${NOFORMAT}"
    pushd "$root_dir" >/dev/null
}

log() {
    echo >&2 -e "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $*"
}

die() {
    local msg=$1
    local code=${2-1}
    log "$msg"
    exit "$code"
}

parse_params() {
    while :; do
        case "${1-}" in
        -h | --help) usage ;;
        -v | --verbose) TRACE=1 ;;
        --no-color) NO_COLOR=1 ;;
        -?*) die "Unknown option: $1" ;;
        *) break ;;
        esac
        shift
    done

    if [[ $# -lt 1 ]]; then
        log "Missing script arguments"
        usage
    fi

    command="$1"
    shift
    args=("$@")

    return 0
}

parse_params "$@"
setup_colors
setup_trace
setup_root

case "$command" in
fmt)
    do_fmt
    ;;
check-fmt)
    do_check_fmt
    ;;
start)
    do_start "${args[@]}"
    ;;
stop)
    do_stop "${args[@]}"
    ;;
gen-static-specs)
    do_gen_static_specs
    ;;
go-update-deps)
    do_go_update_deps
    ;;
go-test)
    do_go_test
    ;;
go-test-int)
    do_go_test_int
    ;;
*)
    usage
    ;;
esac
